<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML+CSS</title>
    <url>/2023/03/06/HTML/</url>
    <content><![CDATA[<p>HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。<br>HTML的英文全称是 Hyper Text Markup Language，即超文本标记语言。HTML是由Web的发明者 Tim Berners-Lee和同事 Daniel W. Connolly于1990年创立的一种标记语言，它是标准通用化标记语言SGML的应用。用HTML编写的超文本文档称为HTML文档，它能独立于各种操作系统平台(如UNIX， Windows等)。使用HTML，将所需要表达的信息按某种规则写成HTML文件，通过专用的浏览器来识别，并将这些HTML文件“翻译”成可以识别的信息，即我们所见到的网页。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2022/12/27/JavaScript/</url>
    <content><![CDATA[<p>JavaScript（JS）是一种具有函数优先特性的轻量级、解释型或者说即时编译型的编程语言。虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多非浏览器环境中，例如 Node.js、Apache CouchDB、Adobe Acrobat 等。进一步说，JavaScript 是一种基于原型、多范式、单线程的动态 (en-US)语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p>
<h2 id="JS代码质量工具"><a href="#JS代码质量工具" class="headerlink" title="JS代码质量工具"></a>JS代码质量工具</h2><p>JavaScript Booster</p>
<h3 id="js获取dom元素的八种方法"><a href="#js获取dom元素的八种方法" class="headerlink" title="js获取dom元素的八种方法"></a>js获取dom元素的八种方法</h3><p>通过ID获取（getElementById）<br>通过name属性（getElementsByName）<br>通过标签名（getElementsByTagName）<br>通过类名（getElementsByClassName）<br>获取html的方法（document.documentElement）<br>获取body的方法（document.body）<br>通过选择器获取一个元素（querySelector）<br>通过选择器获取一组元素（querySelectorAll）</p>
<h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><p>1、get一般用来获取数据（也可以提交请求）post基本上都是用来提交请求<br>2、get 因为参数会放在url中所以隐私性比post差一点get请求的数据长度有大小限制不同的浏览器和服务器不同，一般限制在2~8k左右更见常见的是1k以内<br>post 放在body内没有大小限制。<br>3、get请求刷新服务器或者回退没有影响，post会重新提交数据请求<br>3、get请求可以被浏览器缓存，post 不会被缓存。<br>4、get请求可以被保存到浏览器历史记录中或者添加为标签，而post不可以因为get的参数都放在url中。<br>5、get请求支持的编码只支持application-x-www-from-urlencoded,post支持多种muilpart、from-data<br>深入理解<br>1、报文上的区别<br>get和post 都是http的请求方式 在传输上没有区别，因为http协议是居于tcp&#x2F;ip协议的应用层，协议报文格式上带参数和不带参数最大的区别就是第一行的方法名不同，一个是get一个是post<br>get直接往后面拼 post在content-type<br>2、get参数写法是固定的吗？<br>在约定中参数一般卸载？后面用&amp;分割<br>解析报文的过程是通过tcp获取数据，用正则等工具从数据中获取header和body，从而提取数据。<br>所以也可以不用http 规定的只要后台能解析就行<br>3、post比get安全吗？<br>从传输的角度上讲它们都不是安全的，因为http在网络上是明文传输，只要在网络节点上抓包，就能完整的获取报文。<br>想要安全的传输只有https。</p>
<h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p>1、作用域的目的限制变量访问的环境，在查找某个变量的时候子级作用域会一层一层的往上找，找不到会报错is not defind<br>es6快捷作用域，要配合es6定义变量的方法如const、let </p>
<p>2、全局作用域没有回收机制</p>
<h3 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h3><p>专业的文献：闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。<br>自己理解：闭包就是函数嵌套函数子函数可以访问父级函数里的变量<br>闭包的优缺点：<br>优点：<br>1、可以将一个变量或者方法长期存储在内存中，用于缓存。<br>2、闭包的变量或者方法一直处于引用的状态所以变量不会销毁<br>3、可以避免全局变量的污染。<br>4、比局部变量使用起来更加灵活<br>缺点：<br>由于闭包不会自动释放内存和销毁变量，也就是说当闭包的变量过多时就会占用更多的内存从而导致运行变慢<br>解决方法：在闭包使用结束后手动清楚或者把值置空</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Mozilla&quot;</span>; <span class="hljs-comment">// name 是一个被 init 创建的局部变量</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">displayName</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// displayName() 是内部函数，一个闭包</span><br>      <span class="hljs-title function_">alert</span>(name); <span class="hljs-comment">// 使用了父函数中声明的变量</span><br>  &#125;<br>  <span class="hljs-title function_">displayName</span>();<br>&#125;<br><span class="hljs-title function_">init</span>();<br></code></pre></td></tr></table></figure>
<h3 id="三、this"><a href="#三、this" class="headerlink" title="三、this"></a>三、this</h3><p>this的值是在函数执行时决定的，不是在函数定义时决定<br>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）。this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同。ES5 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。ES2015 引入了箭头函数，箭头函数不提供自身的 this 绑定（this 的值将保持为闭合词法上下文的值）。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>1、什么是原型。<br> 每一个js 对象都有它的原型对象，它可以使用原型对象上的所有属性和方法 。<br> 获取原型的方法有两种<br> 1、__proto__获取<br> 2、通过prototype获取 </p>
<h3 id="四、JavaScript的六种继承方法"><a href="#四、JavaScript的六种继承方法" class="headerlink" title="四、JavaScript的六种继承方法"></a>四、JavaScript的六种继承方法</h3><p><strong>new关键字在创建对象的时候具体都干了什么事？？ 背</strong><br>  在内存中创建了一个虚拟的空对象（为了方便理解 例如：var json &#x3D; {}）<br>  将json对象结构传入到这个函数对象结构本身，<br>  运行当前构造函数对象结构，看在其this环境指向上有无属性或者是方法，<br>  如果函数的this指向上有属性或者是方法，则在这个json对象上进行添加<br>  如果没有则直接返回最初创建的那个空的json对象</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span>实例对象，原型对象，构造函数，prototype __proto__ constructor 之间的关系<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>=<span class="hljs-string">&#x27;小明&#x27;</span><br>&#125; <br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()<br> 构造函数可以通过<span class="hljs-keyword">new</span>的方式来执行<br> 构造函数通过<span class="hljs-keyword">new</span>的方式来执行的话<span class="hljs-title class_">Foo</span> 内部的<span class="hljs-variable language_">this</span>指向将指向当前实例对象 foo<br> 它和函数唯一的区别就是通过函数的执行方式 <span class="hljs-variable language_">this</span> 指向会有所区别<br> prototype是所有实例的公共祖先 实例有能力拿到原型上的属性和方法<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>===<span class="hljs-literal">null</span> <span class="hljs-comment">//true 是终点</span><br><br>constructor 原型上的一个属性 它指向实例对象<br></code></pre></td></tr></table></figure>

<h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p> 数组的原型是array –&gt;array 的原型的对象是Object，只要在原型链上的属性都可以访问<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小明&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">12</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">school</span> = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]<br>    &#125;<br>    <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初中&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Age</span>(<span class="hljs-params"></span>) &#123;<br>    &#125;<br>    <span class="hljs-title class_">Age</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>()<br>    <span class="hljs-keyword">var</span> age1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>*     <span class="hljs-keyword">var</span> age2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>    age1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小红&#x27;</span><br>    age1.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>    age1.<span class="hljs-property">school</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age1)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age2)<br><br></code></pre></td></tr></table></figure></p>
<p>  原型链继承的问题：引用值会共享,无法解决</p>
<p><img src="/images/theme/screenshot/yxl.png"></p>
<h3 id="2、构造函数继承"><a href="#2、构造函数继承" class="headerlink" title="2、构造函数继承"></a>2、构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">school</span> = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]<br>   &#125;<br>   <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初中&#x27;</span>)<br>   &#125;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">Age</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>   &#125;<br>   <span class="hljs-keyword">var</span> age1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>   <span class="hljs-keyword">var</span> age2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>   age1.<span class="hljs-property">school</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age1)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age2)<br></code></pre></td></tr></table></figure>
<p>构造函数继承解决了引用值共享的问题，但是无法拿到原型上的方法<br><img src="/images/theme/screenshot/gzhs.png"></p>
<h3 id="3、组合继承（伪经典继承）"><a href="#3、组合继承（伪经典继承）" class="headerlink" title="3、组合继承（伪经典继承）"></a>3、组合继承（伪经典继承）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">school</span> = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]<br>   &#125;<br>   <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初中&#x27;</span>)<br>   &#125;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">Age</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-number">1</span><br>   &#125;<br>  <span class="hljs-number">2</span> <span class="hljs-title class_">Age</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() <span class="hljs-comment">//会调用两次Student</span><br>   <span class="hljs-keyword">var</span> age1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>   <span class="hljs-keyword">var</span> age2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>   age1.<span class="hljs-property">school</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age1)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age2)<br></code></pre></td></tr></table></figure>


<h3 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h3><p>这里主要借助 <strong>Object.create</strong> 方法实现普通对象的继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">school</span> = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]<br>  &#125;<br>  <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初中&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Age</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>  <span class="hljs-title class_">Age</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>  <span class="hljs-keyword">var</span> age1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>  <span class="hljs-keyword">var</span> age2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>  age1.<span class="hljs-title function_">say</span>()<br>  age2.<span class="hljs-title function_">say</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age1)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age2)<br></code></pre></td></tr></table></figure>
<p>这种继承方式的缺点也很明显，用为object.create 方法实现的是浅拷贝，多个实力的引用类型属性或指向<br>相同的内存，存在篡改的可能</p>
<h3 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h3><p>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> aa = &#123;<br>       <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;parent5&quot;</span>,<br>       <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;p1&quot;</span>, <span class="hljs-string">&quot;p2&quot;</span>, <span class="hljs-string">&quot;p3&quot;</span>],<br>       <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">Age</span>(<span class="hljs-params">a</span>) &#123;<br>       <span class="hljs-keyword">let</span> conle = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(a)<br>       conle.<span class="hljs-property">getSchool</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> conle<br>   &#125;<br>   <span class="hljs-keyword">let</span> school =<span class="hljs-title class_">Age</span>(aa)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(school.<span class="hljs-title function_">getName</span>());<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(school.<span class="hljs-title function_">getSchool</span>())<br></code></pre></td></tr></table></figure>
<p><img src="/images/theme/screenshot/jssjc.png"><br>优缺点和原型式继承一样的缺点</p>
<h3 id="6、寄生组合式继承-经典继承"><a href="#6、寄生组合式继承-经典继承" class="headerlink" title="6、寄生组合式继承(经典继承)"></a>6、寄生组合式继承(经典继承)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">school</span> = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>]<br>   &#125;<br>   <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初中&#x27;</span>)<br>   &#125;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">Age</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>   &#125;<br>   <span class="hljs-title class_">Age</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>   <span class="hljs-keyword">var</span> age1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>   <span class="hljs-keyword">var</span> age2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Age</span>()<br>   age1.<span class="hljs-title function_">say</span>()<br>   age2.<span class="hljs-title function_">say</span>()<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age1)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age2)<br>   <br></code></pre></td></tr></table></figure>


<h3 id="7、clss类继承（es6）"><a href="#7、clss类继承（es6）" class="headerlink" title="7、clss类继承（es6）"></a>7、clss类继承（es6）</h3><p>constructor,extends,super<br>constructor 构造器用来初始化对象成员，可定义属性和方法<br>extends 子类继承父类 例：子 extends 父<br>super 用来获取父类初始化的成员<br>父类不能调用子类的属性和方法，也就是说子类的变化不会影响到父类。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Percons</span>&#123;<br>       <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name<br>       &#125;<br>   &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Percons</span>&#123;<br>       <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)&#123;<br>           <span class="hljs-variable language_">super</span>(name)<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span>=age<br>       &#125;<br>       <span class="hljs-title function_">fs</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> 今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>)<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">var</span> student=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">12</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(student)<br>   student.<span class="hljs-title function_">fs</span>()<br></code></pre></td></tr></table></figure>
<p><img src="/images/theme/screenshot/classjc.png"></p>
<h3 id="ES6和ES5继承的区别"><a href="#ES6和ES5继承的区别" class="headerlink" title="ES6和ES5继承的区别"></a>ES6和ES5继承的区别</h3><p>1、ES5的继承是通过prototype或构造函数的机制来实现的。ES5的继承实质上是先创建子类的实例对象，让后将父类的方法添加到this上call(this)或apply(this)<br>2、ES6的继承机制完全不同，<strong>实质上是先创建父类的实例对象this（所以必须先调用父类的super（）方法），然后再用子类的构造函数修改this。</strong><br>具体的：ES6通过<strong>class</strong>关键字定义类，里面有构造方法，类之间透过<strong>extends</strong>关键字实现继承。子类必须在<strong>constructor</strong>方法中调用<strong>super</strong>方法，否则新建实例报错。<br>因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法子类得不到this对象。<br>ps:<strong>super</strong>方法指代父类的实例，即父类的this对象，在子类的构造函数中，调用<strong>super</strong>后，才可以使用this关键字，否则报错。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案回调函数, 更合理和更强大。<br>解决了回调地狱代码过多难以维护的问题<br>Promise 的三种状态<br>reslove 成功时的状态<br>reject  失败时的状态<br>pedding 未完成时的状态<br>从未完成到成功，从未完成到失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">reslove</span>(&#123;<br>            <span class="hljs-attr">aa</span>:<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">bb</span>:<span class="hljs-number">2</span>,<br>            <span class="hljs-attr">cc</span>:<span class="hljs-number">3</span><br>        &#125;)<br>        <span class="hljs-comment">// reject(&#123;code:500,error:&#x27;请求失败&#x27;&#125;)</span><br>    &#125;)<br>&#125;<br><span class="hljs-keyword">var</span> por=<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;111&#x27;</span>)<br>por.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>,res)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(por)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>,error)<br>&#125;)<br>   <br></code></pre></td></tr></table></figure>
<p>then()<br>catch()<br>finally()<br>then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数<br>then方法返回的是一个新的Promise实例，也就是promise能链式书写的原因<br>catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数<br>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作<br>调用reslove()方法才能调用then，reslove传出来的值是then的形参</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p>async和await 是Generator的语法糖，async关键字代表后面的函数中有异步操作，await 表示等待一个异步方法执行完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a= <span class="hljs-keyword">await</span> ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>async函数 返回一个promise 对象，单独一个async函数 和promise执行的功能是一样的。<br>await 就是等promise的返回结果后才会继续往下执行<br>await 异步等待 等待的是一个promise对象，后面必须跟一个promise对象但是不用写 .then()，直接就可以拿到返回值<br>调用async 函数不会造成代码堵塞，但是在await 会引起async函数内部代码的堵塞</p>
<p>promise 和async&#x2F;await区别<br>promise是通过.thne()和.catch()来去处理数据和捕获异常的，并且是链式调用，虽然比回调函数好很多但是还是容易造成代码多层堆叠难以维护；<br>async&#x2F;await则是通过tyr{}.catch{}进行捕获直接抛出异常<br>async&#x2F;await最大的优点是使代码看起来更像同步遇到await立即执行返回结果在执行后面的操作，promise.then()的方式有可能结果还没返回就已经执行了外面的操作</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>原始类型：数值（Number）、字符串（String）、布尔（Boolean）、空（Null）、未定义（Undefined），<strong>存在于栈内存</strong>。<br>引用类型：对象、数组、function，<strong>存在与堆内存</strong><br>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>    <span class="hljs-keyword">let</span> cat = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;旺财&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> dog = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;喵喵&#x27;</span>,<br>        <span class="hljs-attr">seayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">food1, food2</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;我喜欢吃&#x27;</span> + food1 + <span class="hljs-string">&#x27;和&#x27;</span> + food2);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// fn.call(cat)</span><br>    <span class="hljs-comment">// dog.seayName.call(cat,&#x27;鱼&#x27;,&#x27;rou&#x27;)</span><br>    <span class="hljs-comment">// dog.seayName.apply(cat,[&#x27;鱼&#x27;,&#x27;肉&#x27;])</span><br>    <span class="hljs-comment">// let a= dog.seayName.bind(cat,&#x27;鱼&#x27;,&#x27;rou&#x27;)</span><br>    <span class="hljs-title function_">a</span>()<br></code></pre></td></tr></table></figure>
<p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Student1</span> = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;2&#x27;</span>,<br>        <span class="hljs-attr">grieFrind</span>: &#123;<br>            <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;小花&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">obj</span>) &#123;<br>        <span class="hljs-keyword">let</span> newObj = &#123;&#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>            <span class="hljs-keyword">if</span> (obj[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;<br>                newObj[i] = <span class="hljs-title function_">copy</span>(obj[i])<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                newObj[i] = <span class="hljs-title class_">Student1</span>[i]<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newObj<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Student2</span> = <span class="hljs-title function_">copy</span>(<span class="hljs-title class_">Student1</span>)<br>    <span class="hljs-comment">// Student1.grieFrind.name=&#x27;小王&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student2</span>);<br></code></pre></td></tr></table></figure>


<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><p>防抖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ipt = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>)<br>   ipt.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">denounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>   &#125;, <span class="hljs-number">500</span>)<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">denounce</span>(<span class="hljs-params">fn, del</span>) &#123; <span class="hljs-comment">//防抖，只执行最后一次</span><br>       <span class="hljs-keyword">var</span> tiem = <span class="hljs-literal">null</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-keyword">if</span> (tiem !== <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-built_in">clearTimeout</span>(tiem)<br>           &#125;<br>           tiem = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>               fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br><br>           &#125;, del)<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>节流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//节流 作用：控制高频事件的发生 隔一段时间执行一次</span><br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>   &#125;, <span class="hljs-number">500</span>)<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, del</span>) &#123;<br>       <span class="hljs-keyword">var</span> t = <span class="hljs-literal">true</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-keyword">if</span> (t) &#123;<br>               <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                   fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>                   t = <span class="hljs-literal">true</span><br>               &#125;, del);<br>               t = <span class="hljs-literal">false</span><br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h3 id="call、apply、bind的基本概念"><a href="#call、apply、bind的基本概念" class="headerlink" title="call、apply、bind的基本概念"></a>call、apply、bind的基本概念</h3><p>三种都是用来改变this指向的，其中call和apply的传参方式不同apply的传参方式是数组而call是逗号隔开依次往后排，<br>bind的传参方式和call一摸一样但是不会调用函数它会以返回值的形式返回<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>   &#125;<br>   <span class="hljs-keyword">let</span> cat = &#123;<br>       <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;旺财&#x27;</span><br>   &#125;<br>   <span class="hljs-keyword">let</span> dog=&#123;<br>       <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;喵喵&#x27;</span>,<br>       <span class="hljs-attr">seayName</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">food1,food2</span>)&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>+<span class="hljs-string">&#x27;我喜欢吃&#x27;</span>+food1+<span class="hljs-string">&#x27;和&#x27;</span>+food2);<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">// fn.call(cat)</span><br>   <span class="hljs-comment">// dog.seayName.call(cat,&#x27;鱼&#x27;,&#x27;rou&#x27;)</span><br>   <span class="hljs-comment">// dog.seayName.apply(cat,[&#x27;鱼&#x27;,&#x27;肉&#x27;])</span><br>   <span class="hljs-keyword">let</span> a= dog.<span class="hljs-property">seayName</span>.<span class="hljs-title function_">bind</span>(cat,<span class="hljs-string">&#x27;鱼&#x27;</span>,<span class="hljs-string">&#x27;rou&#x27;</span>)<br>   <span class="hljs-title function_">a</span>()<br></code></pre></td></tr></table></figure></p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>先执行同步任务后执行异步任务<br><strong>一、单线程</strong><br>一个任务执行完之后才能执行另一个<br><strong>二、process.nexTick和setlmmediate方法</strong><br>process.nexTick()在同步之后异步之前执行<br>setlmmediate()异步之后执行<br><strong>三、事件循环</strong><br>事件循环会持续的循环任务队列里的方法有任务则放到运行栈里<br><strong>宏任务，微任务</strong><br>宏任务：计时器，ajax，读取文件<br>微任务：promise,.then<br><strong>注意：new Promise里的代码是同步的，then放到任务队列是异步的</strong><br>执行顺序：<br>1、同步程序<br>2、process.nexTick()<br>3、微任务<br>4、宏任务<br>5、setlmmediate()<br><img  src="/images/theme/screenshot/JavaScriptYXJZ.png"  ><span class="image-caption">运行机制图解</span></p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>JavaScript的垃圾回收机制，清除无用的变量释放多余的内存，展现更好的性能。<br>在JavaScript中，具有自动垃圾回收机制，也就是说执行环境会自动负责管理代码执行过程中的内存使用情况，会自动清除一些用不到的变量，<br>以此来释放内存，该机制每隔一段时间会执行一次。<br>JavaScript中能实现垃圾回收机制的方式一共有两种：<strong>标记清除，引用计数</strong><br><strong>标记清除</strong><br>标记清除是JavaScript中最常用的垃圾回收方式。它的执行方式是在执行环境中每创建一个变量，就会对该变量进行标记，等到执行垃圾回收机制时在根据标记来决定是否进行回收。<br><strong>引用计数</strong><br>引用计数 是一种不太常用的回收机制 顾名思义就是针对值为引用数据类型的变量进行计数。<br>引用计数的回收机制是当声明一个变量就会给改变量设定一个值为0的引用次数，当改变量被引用了引用次数就会+1取消则-1若引用次数不变一直为0就会被回收机制给清除不为0则不做任何更改</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p>通过script标签没有跨域限制的漏洞来获取数据<br>缺点：不安全只能用于get方式<br>优点：兼容性好</p>
<h4 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h4><p>需要浏览器和后端同时支持<br>浏览器会自动进行cors 通讯实现cors通信的关键是后端。<br>虽然设置cors 后前端没什么关系但是通过这种方式解决跨域，会在发送请求时会出现两种情况，分别是简单跨域和复杂跨域。<br>条件：1<br>1、简单跨域使用下列条件之一<br>  get、head、post<br>条件：2<br>2、Content-type 的值仅限于下列三者之一<br>  text&#x2F;plain<br>  multipart&#x2F;form-data<br>  application&#x2F;x-www-form-urlencoded</p>
<p>  不符合以上条件的请求就是复杂请求，cors会在正式请求之前发送一个普通的http请求，称为 <strong>预检</strong> 请求<br>  是cors用来确定服务端是否允许跨域请求。</p>
<h4 id="node中间件代理-两次跨域"><a href="#node中间件代理-两次跨域" class="headerlink" title="node中间件代理(两次跨域)"></a>node中间件代理(两次跨域)</h4><pre><code>同源策略是浏览器需要遵循的标注，如果是服务器向服务器发送请求就不需要遵循同源策略
</code></pre>
<p>原理：<br>    1、客户端向代理服务器发送请求，代理服务器转发给服务器<br>    2、服务器响应返回给代理服务器，代理服务器在返回给客户端</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">server</span>: &#123;<br>   <span class="hljs-comment">// 设置为0.0.0.0则所有的地址均能访问</span><br>     <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <br>     <span class="hljs-attr">port</span>: <span class="hljs-number">5001</span>,<br>     <span class="hljs-attr">https</span>: <span class="hljs-literal">false</span>,<br>     <span class="hljs-attr">hmr</span>: &#123;<br>       <span class="hljs-attr">overlay</span>: <span class="hljs-literal">false</span><br>     &#125;,<br>      <span class="hljs-comment">// 跨域问题解决 代理（关键部分）</span><br>     <span class="hljs-attr">proxy</span>: &#123;<br>       <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>         <span class="hljs-attr">target</span>: env.<span class="hljs-property">VITE_BASE_URL</span>, <span class="hljs-comment">//接口地址</span><br>         <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//允许跨域</span><br>         <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-comment">//路径重写</span><br>       &#125;<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h4><p>跨域的解决方案思路两种，躲避绕过去和cors；<br>各种iframe方式可传递数据，但组织和控制代码逻辑太复杂，鸡肋；<br>jsonp前几年使用，现在浏览器兼容性高了，以及受限于仅get方式，逐步淘汰了；<br>nginx反向代理是绕过去的方式，是从古至今通吃的没完解决方案，缺点也许是服务器压力大一点，实际中那点压力根本不是大问题；同时反向代理更适合内部应用间访问和共享；<br>cors才是真正的称得上跨域请求解决方案，因为请求存在跨域，结果是拿到了数据，也就是说服务器和浏览器之间进行了协商通信控制后，才得以允许或拒绝；<br>最后说明下，跨域请求产生时，请求是发出去了，也是有响应的，仅仅是浏览器同源策略，认为不安全，拦截了结果，不将数据传递我们使用罢了</p>
]]></content>
  </entry>
  <entry>
    <title>Pinia</title>
    <url>/2022/12/30/Pinia/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>React</title>
    <url>/2022/12/27/React/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2022/12/27/TypeScript/</url>
    <content><![CDATA[<p>什么是 TypeScript？<br>TypeScript，简称 ts，是微软开发的一种静态的编程语言，它是 JavaScript 的超集。 那么它有什么特别之处呢?</p>
<p>简单来说，js 有的 ts 都有，所有js 代码都可以在 ts 里面运行。<br>ts 支持类型支持，ts &#x3D; type +JavaScript。<br>那么 ts 和 js 有什么区别呢？<br>JavaScript 属于动态编程语言，而ts 属于静态编程语言。<br>js：边解释边执行，错误只有在运行的时候才能发现<br>ts：先编译再执行，在写的时候就会发现错误了（ts不能直接执行，需要先编译成 js ）<br>ts 完全支持 js ，可以直接转换</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>1·基础类型<br>string、number、Boolean、null、undefined、symbol、Biglnt。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//列</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:string=<span class="hljs-string">&#x27;aa&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:string|number=<span class="hljs-string">&#x27;aa&#x27;</span><br><span class="hljs-comment">// 变量：类型|...</span><br><br><br></code></pre></td></tr></table></figure>
<p>2·引用类型<br>array、object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//列 </span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:(number|string|boolean)[]=[]<br><span class="hljs-comment">//加括号表示这个数组可以写入上边三个类型的值</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:number|boolean|string[]=[]<br><span class="hljs-comment">//多个类型不加括号表示string类型的只能是数组</span><br></code></pre></td></tr></table></figure>


<h3 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a><strong>any类型</strong></h3><p>包括了所有类型,和js一样没有类型校验，不推荐使用<br><strong>unknow类型</strong><br>特点：unknown 类型可以接受任意类型，但是无法赋值给其他类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:unknown=<span class="hljs-string">&#x27;haha&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:string=a <span class="hljs-keyword">as</span> string<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:string=<span class="hljs-string">&#x27;99&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:number=a <span class="hljs-keyword">as</span> number <span class="hljs-comment">//这样不可以转换</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>:number=a <span class="hljs-keyword">as</span> unKnown <span class="hljs-keyword">as</span> number <span class="hljs-comment">//用unknow 作为中间转换层 在进行转换</span><br><span class="hljs-comment">// as 类型断言|类型转换</span><br></code></pre></td></tr></table></figure>
<h3 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a><strong>void类型</strong></h3><p>只能将其赋值为null或undefind，多用于函数返回值<br><strong>never类型</strong><br>可以赋值给任意类型，但是无法给never赋值其他类型<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 手动通过 throw 抛出一个异常（错误）</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;err...&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a><strong>enum枚举</strong></h3><p> 枚举是列举固定几个值，用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。<br>直接定义变量的话的话可以随意定义，枚举只能使用你定义好的几个值<br>例如你定义一个方法接收一个参数，这个参数如果是int型，别人在调用你这个方法时可以传1或2等任意数字，虽然你告诉了同事，只能传0或1,<br>如果你把参数定义成只能传某个类型，例如是个枚举类，那么别人只能传你枚举类里定义好的几个类型，传其它的就会在编译时期报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">enum type&#123;<br>  boy=<span class="hljs-string">&#x27;nan&#x27;</span>,<br>  gril=<span class="hljs-string">&#x27;nv&#x27;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type.<span class="hljs-property">boy</span>);<br></code></pre></td></tr></table></figure>

<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a><strong>断言</strong></h3><p>我想让它是什么类型就是什么类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">ags: boolean</span>):string|number &#123;<br>  <span class="hljs-keyword">return</span> ags ? <span class="hljs-string">&#x27;断言&#x27;</span> : <span class="hljs-string">&#x27;断言失败&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> b = <span class="hljs-title function_">a</span>(<span class="hljs-literal">true</span>) <span class="hljs-keyword">as</span> number<br>b=<span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><br></code></pre></td></tr></table></figure>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a><strong>值类型</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//值类型 as const断言</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-string">&#x27;aaa&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;12&#x27;</span> = <span class="hljs-string">&#x27;12&#x27;</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br><span class="hljs-keyword">const</span> arr = [c, a, <span class="hljs-number">111</span>, <span class="hljs-number">222</span>,<span class="hljs-literal">true</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br><span class="hljs-comment">//as const 拿的是具体的值 来判断类型</span><br></code></pre></td></tr></table></figure>
<h3 id="数组使用const断言"><a href="#数组使用const断言" class="headerlink" title="数组使用const断言"></a><strong>数组使用const断言</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a=<span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-number">123</span><br><span class="hljs-keyword">let</span> c=[a,b]<span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br><span class="hljs-comment">// let c=&lt;const&gt;[a,b]</span><br><span class="hljs-keyword">let</span> d =c[<span class="hljs-number">0</span>] <br>d=<span class="hljs-string">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="赋值结构中使用as"><a href="#赋值结构中使用as" class="headerlink" title="赋值结构中使用as"></a><strong>赋值结构中使用as</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 赋值结构中使用断言</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hd</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;周&#x27;</span><br>  <span class="hljs-keyword">let</span> b = (<span class="hljs-attr">x</span>: number, <span class="hljs-attr">y</span>: number): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> x + y<br>  <span class="hljs-keyword">return</span> [a, b]<span class="hljs-keyword">as</span> [string, <span class="hljs-title class_">Function</span>]<br>&#125;<br><span class="hljs-comment">// const [n, m] = hd() </span><br><span class="hljs-comment">// (m as Function)(1,2)</span><br><br><span class="hljs-keyword">const</span> [n, m] = <span class="hljs-title function_">hd</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">m</span>(<span class="hljs-number">12</span>,<span class="hljs-number">22</span>));<br></code></pre></td></tr></table></figure>
<h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a><strong>非空断言</strong></h3><p>？！</p>
<h3 id="constructor构造函数在ts-中的特性"><a href="#constructor构造函数在ts-中的特性" class="headerlink" title="constructor构造函数在ts 中的特性"></a><strong>constructor构造函数在ts 中的特性</strong></h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-comment">// public name: string  先声明后使用 可以缩写为在使用的时候用修饰符进行修饰，不修饰会报错</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initName</span>(name)<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">initName</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>-zzzz`</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> aa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;吱吱吱吱&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(aa.<span class="hljs-property">name</span>);<br><br></code></pre></td></tr></table></figure>
<h3 id="static静态属性语法使用"><a href="#static静态属性语法使用" class="headerlink" title="static静态属性语法使用"></a><strong>static静态属性语法使用</strong></h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-attr">site</span>:<span class="hljs-built_in">string</span>=<span class="hljs-string">&#x27;123&#x27;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getSite</span>():<span class="hljs-built_in">string</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">User</span>.<span class="hljs-property">site</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 静态属性只能通过构造函数调用，实例里面是没有的</span><br><span class="hljs-keyword">const</span> instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>()<br><span class="hljs-comment">// console.log(User.site);</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">User</span>.<span class="hljs-title function_">getSite</span>());<br></code></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Axios</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">Axios</span> | <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// console.log(&#x27;121&#x27;)</span><br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">make</span>(): <span class="hljs-title class_">Axios</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Axios</span>.<span class="hljs-property">instance</span> == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;创建实例&#x27;</span>);<br>      <span class="hljs-title class_">Axios</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Axios</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Axios</span>()<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> instance = <span class="hljs-title class_">Axios</span>.<span class="hljs-title function_">make</span>()<br><span class="hljs-keyword">const</span> instance2 = <span class="hljs-title class_">Axios</span>.<span class="hljs-title function_">make</span>()<br><span class="hljs-keyword">const</span> instance3 = <span class="hljs-title class_">Axios</span>.<span class="hljs-title function_">make</span>()<br><span class="hljs-comment">// 通过静态函数生成实例 只生成一次实例</span><br></code></pre></td></tr></table></figure>

<h3 id="访问器get和set"><a href="#访问器get和set" class="headerlink" title="访问器get和set"></a><strong>访问器get和set</strong></h3>]]></content>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2022/12/27/Vue/</url>
    <content><![CDATA[<p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>1、.stop阻止事件冒泡，相当于event.stopPropagation方法。<br>2、.prevent阻止事件默认行为，相当于event.preventDefault方法。<br>3、.once 只执行一次以后不再执行。<br>4、.captuer 当元素发生冒泡时，谁带有此修饰符就先执行谁，若有多个则从外向内触发。<br>5、.native 给组件绑定原生事件，当成普通的html标签看待。<br>6、.passive 执行默认行为和prevent 是对立关系 每次产生时间浏览器都会查询是否有preventDefault阻止该次事件的默认动作 此修饰符就是为了告诉浏览器不用查询我们没有preventDefault阻止默认动作。<br>7、.self 只有触发当前事件的时候才执行冒泡不会执行。</p>
<h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><p>1、.number 只能是数字<br>2、.trim 过滤用户输入的首尾空字符<br>2、.lazy 在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步</p>
<h3 id="虚拟Dom和diff算法Vue2"><a href="#虚拟Dom和diff算法Vue2" class="headerlink" title="虚拟Dom和diff算法Vue2"></a>虚拟Dom和diff算法Vue2</h3><p>虚拟Dom就是一个普通的js对象是用来描述真实Dom结构的js对象，因为不是真是的Dom结构，所以叫做虚拟Dom。<br>虚拟Dom是个对象有6个属性 。<br> (sel) 表示当前节点的标签名。<br> (data) 表示节点上的属性。<br> (elm)表示虚拟节点对应的真是Dom节点。<br> (text)对应当前节点下的文本。<br> (key)当前节点的表示。<br> (childre) 表示当前节点下的其他子节点。<br> <strong>虚拟Dom的作用</strong><br> 传统的Dom在数据发生改变时，需要不断的去操作Dom，虽然后面出现了模板引擎虽然它可以一次性更新多个Dom，但是它没有一个追踪状态的机制，当引擎内的某个数据发生变化时它依然需要操作Dom去重现渲染整个引擎。<br> 虚拟Dom有可以很好的跟踪当前Dom的状态，虚拟Dom会根据当前的数据生成一个描述当前Dom的虚拟Dom，在数据发生变化时又会生成一个新的虚拟Dom，这两个虚拟Dom正好就是变化前和变化后的状态，然后通过diff算法进行比较，哪里有变化就更新哪里。可以大大的提高页面渲染的效率，提高用户的体验。<br><img  src="/images/theme/screenshot/vmDom.png"  ><span class="image-caption">虚拟Dom结构</span><br>vue2后使用的都是snabbdom 虚拟dom类库</p>
<p>snabbdom 中几个重要的核心方法<br>h函数<br>patch函数<br>patchVnode函数<br>updateChildren函数</p>
<p>h函数是在render函数内运行的vue在created &gt; beforeMount之间的时候会将模板编译成某种格式放到render函数内，执行render函数的时候生成虚拟Dom。<br><img  src="/images/theme/screenshot/functionH.png"  ><span class="image-caption">h函数</span><br>h函数以函数重载的方式定义的<br><strong>什么是函数重载</strong><br>函数重载就是定义多个同名的函数，利用函数的类型以及参数类型来区分，当参数个数不同，参数类型不同时，函数内执行的代码也会不同。<br>h函数内最重要的就是执行了vnode函数 vnode函数主要作用就将h函数传来的参数转成了js对象，既虚拟Dom。</p>
<p>vnode函数就是生成了js对象就是虚拟Dom</p>
<p>代码初次运行时生命周期走到created和beforeMount 之间时会把template模板编译成某种格式放到render函数内，然后当render函数执行时，h函数被调用，而h函数内调用啦vnode函数并生成虚拟Dom，并返回结果。<br>之后每次数据发生改变时都会生成新的虚拟dom，再然后就是新旧虚拟Dom的对比。</p>
<p><strong>diff比较规则</strong><br>diff整体策略：深度优先，同层比较<br>1、diff比较两个虚拟Dom只会在同层级比较不会跨层比较。<br>2、比较的过程中循环从两边向中间收拢</p>
<p><strong>patch</strong><br>patch函数是比较的开始，patch函数中对根节点进行比较<br>非根节点都是在updateChildren函数中执行<br><strong>patcVnode</strong><br>patchVnode是比较两个相同节点的子级(文本|子节点)的一个函数，所以它的调用是在新dom判断之后，只有判断两个节点相同的时候才会被执行。<br>作用：对比新旧两个节点，更新dom的子级(子级包含文本或子节点)</p>
<h3 id="Vue3虚拟dom和diff算法"><a href="#Vue3虚拟dom和diff算法" class="headerlink" title="Vue3虚拟dom和diff算法"></a>Vue3虚拟dom和diff算法</h3>]]></content>
  </entry>
  <entry>
    <title>Gitee</title>
    <url>/2022/12/27/gitee/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>TCP/IP协议</title>
    <url>/2023/03/02/tcp/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
